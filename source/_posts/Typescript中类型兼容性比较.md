---
title: Typescript中类型兼容性比较
date: 2023-04-11 22:22:13
tags:
  - TypeScript
---

这一问题主要考察你是否了解 TypeScript 类型系统的基本工作原理，以及使用的深入程度。因为通常来说，只有具有一定经验的使用者才会开始了解类型兼容性的相关规则，而了解这部分规则也就意味着你至少能够独立解决相当一部分类型报错。

### 及格线

TypeScript 使用鸭子类型，也即结构化类型系统进行类型兼容性的比较，即对于两个属性完全一致的类型，就认为它们属于同一种类型。而对于 A 类型、A + B 类型，认为后者属于前者的子类型。另外 TypeScript 类型中还存在着一部分特殊的规则，如 object、{} 以及 Top Type 等。

### 优秀回答

能回答出上面这些内容已经不错了，但你可是阅读完了这本小册的同学，怎么能轻易止步。如果想进一步升华回答，还可以从以下方面进行扩展。

- **结构化类型系统到标称类型系统**，你可以表达你不仅了解结构化类型系统，还了解与其可以作为对比的标称类型系统，包括存在意义与比较方式，以及如何在 TS 中实现标称类型系统。
- **类型层级**，类型兼容性的比较本质上其实也就是在类型层级中进行比较，一个类型能够兼容其子类型，就这么回事，因此，不妨扩展地讲一讲 TS 的类型层级是怎么样的。
    - 类型层级初探

      这一节的知识点其实都和 TypeScript 的类型层级有所关联，我们会在后面的类型系统部分有专门一节进行详细地讲述，这里只做简单地描述来供有兴趣的同学提前了解。

      前面我们已经说到，any 与 unknown 属于 **Top Type**，表现在它们包含了所有可能的类型，而 never 属于 **Bottom Type**，表现在它是一个虚无的、不存在的类型。那么加上此前学习的原始类型与字面量类型等，按照类型的包含来进行划分，我们大概能梳理出这么个类型层级关系。

        - 最顶级的类型，any 与 unknown
        - 特殊的 Object ，它也包含了所有的类型，但和 Top Type 比还是差了一层
        - String、Boolean、Number 这些装箱类型
        - 原始类型与对象类型
        - 字面量类型，即更精确的原始类型与对象类型嘛，需要注意的是 null 和 undefined 并不是字面量类型的子类型
        - 最底层的 never
